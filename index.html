<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Byeage Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Byeage Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Byeage Blog">
<meta property="og:description" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Byeage Blog">
<meta name="twitter:description" content="博客">
  
    <link rel="alternate" href="/atom.xml" title="Byeage Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Byeage Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">白痴总得加把劲</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test-e2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/test-e2e/" class="article-date">
  <time datetime="2017-05-22T09:55:00.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/22/test-e2e/">test-e2e</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是nightwatch？"><a href="#什么是nightwatch？" class="headerlink" title="什么是nightwatch？"></a>什么是nightwatch？</h3><p><a href="http://nightwatchjs.org/api#expect-negation" target="_blank" rel="external">nightwatch</a> 是一个用nodejs 写的用于网站和网页应用的自动化测试框架。简化可持续集成的设置和测试的编写，也可以用于nodejs的单元测试</p>
<p>设置配置可看官方文档，有点复杂😅，这里主要讲讲如何在Vue-cli 构建的项目里使用nightwatch 进行end-to-end测试</p>
<p>在test/e2e/specs/ 文件下有一个默认的测试文件的例子 test.js， nightwatch.conf.js 和 runner.js 都为配置文件，custom-assertions 里面为自定义断言，reports 为测试报告</p>
<p>首先得先停运运行你的npm run dev  ctrl + c 。 不然运行下你的 npm run e2e时候就嗝屁了，这看下他的配置大概就能理解了</p>
<pre><code>module.exports = {
    &apos;default e2e tests&apos;: function (browser) {  // 测试描述
        // automatically uses dev Server port from /config.index.js // 用于测试的服务器
        // default: http://localhost:8080 //  默认测试端口
        // see nightwatch.conf.js  // nightwatch 的配置文件

        const devServer = browser.globals.devServerURL  // 测试地址

        browser
        .url(devServer)    // A
        .waitForElementVisible(&apos;#app&apos;, 5000) //B  
        .assert.elementPresent(&apos;.hello&apos;) // C
        .assert.containsText(&apos;h1&apos;, &apos;Welcome to Your Vue.js App&apos;) // D
        .assert.elementCount(&apos;img&apos;, 1) // E
        .end() // F
    }
}
</code></pre><ul>
<li>A 浏览器加载目标地址</li>
<li>B 在断言之前等待5000让页面中#app的元素可见 ，如果在设置对时间内，元素未出现，测试失败</li>
<li>C 页面有存在 .hello 元素</li>
<li>D h1 标签里包含文本 ‘Welcome to Your Vue.js App’</li>
<li>E 页面了有img元素1个</li>
<li>F 结束</li>
</ul>
<h3 id="在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子-baidu-js"><a href="#在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子-baidu-js" class="headerlink" title="在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子 baidu.js"></a>在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子 baidu.js</h3><pre><code>module.exports = {
    &apos;Demo test Baidu&apos;: function (browser) {
        browser
        .url(&apos;https://www.baidu.com/&apos;)
        .waitForElementVisible(&apos;body&apos;, 1000)
        .setValue(&apos;input#kw&apos;, &apos;邪马台&apos;)  // A
        .waitForElementVisible(&apos;input#su&apos;, 1000) // B
        .click(&apos;input#su&apos;) // C
        .pause(1000) // D
        .assert.containsText(&apos;#container&apos;, &apos;邪马台_百度百科&apos;) // E
        .end()
    }
}
</code></pre><p>上面讲过的就不重复了 </p>
<ul>
<li>A 等待body页面加载，设置百度搜索框的值为‘邪马台’</li>
<li>B 等待百度搜索提交按钮出现（这个其实默认就有，沿着谷歌的例子没去掉）</li>
<li>C 触发鼠标单击事件，模拟搜索</li>
<li>D 等待1秒</li>
<li>E 断言#container 元素里文本包含 ‘邪马台_百度百科’</li>
</ul>
<h3 id="分步测试-muiltiple-step-js"><a href="#分步测试-muiltiple-step-js" class="headerlink" title="分步测试 muiltiple-step.js"></a>分步测试 muiltiple-step.js</h3><p>module.exports = {<br>        ‘Step one’: function (browser) {<br>            browser<br>            .url(‘<a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a>‘)<br>            .waitForElementVisible(‘body’, 1000)<br>            .setValue(‘input#kw’, ‘邪马台’)<br>            .waitForElementVisible(‘input#su’, 1000)<br>            .click(‘input#su’)<br>            .pause(1000)<br>        },<br>        ‘Step two’: function(browser) {<br>            browser<br>            .assert.containsText(‘#container’, ‘邪马台_百度百科’)<br>            .end()<br>        }<br>    }</p>
<p>这个就很好理解了，不做过多解释</p>
<h3 id="使用选择器-selectors-js"><a href="#使用选择器-selectors-js" class="headerlink" title="使用选择器 selectors.js"></a>使用选择器 selectors.js</h3><pre><code>module.exports = {
    &apos;selector Test&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;/index&apos;
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        .useXpath() // A
        .assert.containsText(&apos;//*[@id=&quot;app&quot;]/div[1]/h1[2]&apos;, &apos;Test example&apos;)
        .useCss() // B
        .assert.containsText(&apos;.test-example&apos;, &apos;Test example&apos;)
        .end()
    }
}
</code></pre><ul>
<li>A 使用xpath 选择器 谷歌F12 在Element里选择元素右键copy 选择 copy Xpath 具体规则自己百度</li>
<li>B 使用Css 选择器</li>
</ul>
<h3 id="BBT-行为驱动开发测试-其实是一种断言的方式，极大提高了断言的可读性和优雅性😂-。具体语法参照-chai"><a href="#BBT-行为驱动开发测试-其实是一种断言的方式，极大提高了断言的可读性和优雅性😂-。具体语法参照-chai" class="headerlink" title="BBT 行为驱动开发测试  其实是一种断言的方式，极大提高了断言的可读性和优雅性😂 。具体语法参照 chai"></a>BBT 行为驱动开发测试  其实是一种断言的方式，极大提高了断言的可读性和优雅性😂 。具体语法参照 <a href="http://chaijs.com/api/" target="_blank" rel="external">chai</a></h3><pre><code>module.exports = {
    &apos;BBD-style Test&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;/index&apos;

        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        browser.expect.element(&apos;.test-hello&apos;).to.be.present
        browser.expect.element(&apos;.test-hello&apos;).text.to.equal(&apos;Welcome to Your Vue.js App&apos;)
        browser.expect.element(&apos;.test-hello&apos;).text.to.contain(&apos;Welcome&apos;)
        browser.expect.element(&apos;.test-hello&apos;).to.be.an(&apos;h1&apos;)
        browser.expect.element(&apos;.test-hello&apos;).to.be.visible
        browser.end()
    }
}
</code></pre><p>有个缺点是expect 不能用链式的方式些，每个断言必须单独使用，expect 相对于 asserts 使用</p>
<h3 id="测试中的钩子"><a href="#测试中的钩子" class="headerlink" title="测试中的钩子"></a>测试中的钩子</h3><pre><code>module.exports = {
    before: function(browser) {
        console.log(&apos;Setting up...&apos;);// A
    },
    after: function(browser) {
        console.log(&apos;Closing down...&apos;); // B
    },

    beforeEach: function(browser) { // C
        const devServer = browser.globals.devServerURL
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 3000)
    },

    afterEach: function(browser, done) { // D
        console.log(&apos;each end&apos;)
        done()
    },

    &apos;hook Test .test-example&apos;: function (browser) {
        browser
        .assert.containsText(&apos;.test-example&apos;, &apos;Test example&apos;)
        .end()
    },
    &apos;hook Test .test-hello&apos;: function (browser) {
        browser
        .assert.containsText(&apos;.test-hello&apos;, &apos;Welcome to Your Vue.js App&apos;)
        .end()
    }
};
</code></pre><ul>
<li>A 在整个测试运行之前运行一次</li>
<li>B 在整个测试完成之后运行一次</li>
<li>C 在每一个小测试运行之前运行一次</li>
<li>D 在每一次小测试运行完之后运行一次</li>
</ul>
<h3 id="现在拿一个自己写的Vue的例子-index-js"><a href="#现在拿一个自己写的Vue的例子-index-js" class="headerlink" title="现在拿一个自己写的Vue的例子 index.js"></a>现在拿一个自己写的Vue的例子 index.js</h3><pre><code>module.exports = {
    &apos;Index e2e tests&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;#/index&apos; // 需要测试的地址
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        .assert.elementPresent(&apos;.show&apos;) // 默认显示是存在的
        .click(&apos;.switch&apos;) // click 之后 show 为false
        .assert.elementNotPresent(&apos;.show&apos;) // 元素不存在了
        .end()
    }
}
</code></pre><h3 id="待续……"><a href="#待续……" class="headerlink" title="待续……"></a>待续……</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/test-e2e/" data-id="cj2zypnr50008t6fy4bgdlhou" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test-unit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/19/test-unit/" class="article-date">
  <time datetime="2017-05-19T02:58:01.000Z" itemprop="datePublished">2017-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/19/test-unit/">test unit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>测试可以分成几类，单元测试，集成测试</li>
<li>TDD（测试驱动开发）直白的说就是先写测试用例，再写代码，直到测试通过</li>
</ul>
<p>代码不出错一般是不正常的（共识）。测试一般指是自动测试的简称，运行测试代码来验证自己写的代码</p>
<p>进行代码测试的好处</p>
<ul>
<li>增强对自己代码的信任度，（为好找借口推脱责任增强自信心） 😀</li>
<li>当你修改、重构代码时，不需要人工再去验证重构完后的代码有没有问题</li>
<li>验证你的代码是正常可行的</li>
</ul>
<h3 id="Test-driven-development-TDD"><a href="#Test-driven-development-TDD" class="headerlink" title="Test-driven development TDD"></a>Test-driven development TDD</h3><p>TDD 测试的三个流程<br><img src="/2017/05/19/test-unit/tdd.png" alt="TDD"></p>
<ol>
<li>red Step 在你写真实的代码之前，先写测试用例的代码。当然写完之后的测试用例都是通不过的</li>
<li>green step 在完测试用例之后开始写你自己真实的代码，过程中，测试用例会一个个的通过，由red 状态转成 red 状态，一旦通过所有测试用例，就跳转到了step 3</li>
<li>refactor step 重构优化阶段， 可以放纵的重构，反正由测试代码帮你验证通过与否</li>
<li>repeat process  添加新的测试用例，重复上述步骤</li>
</ol>
<p>常用测试工具 <strong><em>Mocha</em></strong> <strong><em>chai</em></strong> <strong><em>supertest</em></strong> <strong><em>cheerio</em></strong></p>
<p><img src="/2017/05/19/test-unit/structure.png" alt="structure"></p>
<h3 id="capitalize-js"><a href="#capitalize-js" class="headerlink" title="capitalize.js"></a>capitalize.js</h3><pre><code>function capitalize(str) {
    var firstLetter = str.charAt(0).toUpperCase();
    var rest = str.slice(1).toLowerCase();
    return firstLetter + rest
}

module.exports = capitalize;
</code></pre><hr>
<h3 id="test-capitalize-js"><a href="#test-capitalize-js" class="headerlink" title="/test/capitalize.js"></a>/test/capitalize.js</h3><pre><code>var capitialize = require(&apos;../capitalize&apos;);
var chai = require(&quot;chai&quot;);
var expect = chai.expect;

describe(&quot;capitalize&quot;, function() {
    it(&quot;capitializes single words&quot;, function() {
        expect(capitialize(&quot;express&quot;)).to.equal(&quot;Express&quot;);
        expect(capitialize(&quot;cats&quot;)).to.equal(&quot;Cats&quot;);
    })

    it(&quot;makes the rest of the string lowercase&quot;, function(){
        expect(capitialize(&quot;javaScript&quot;)).to.equal(&quot;Javascript&quot;);
    })
    it(&quot;leaves empty strings alone&quot;, function () {
        expect(capitialize(&quot;&quot;)).to.equal(&quot;&quot;);
    })
    it(&quot;throws an error if passed a number&quot;, function() {
        expect(function() {
            capitialize(123)
        }).to.throw(Error)
    })
    // 反向测试
    it(&quot;changes the value&quot;, function() {
        expect(capitialize(&quot;foo&quot;)).not.to.equal(&quot;foo&quot;);
    })
})
</code></pre><hr>
<h3 id="user-js"><a href="#user-js" class="headerlink" title="user.js"></a>user.js</h3><pre><code>function User(params) {
    this.firstName = params.firstName || &apos;&apos;;
    this.lastName = params.lastName || &apos;&apos;;
    this.birthDay = params.birthday || &apos;&apos;;
}

User.prototype.getName = function() {
    return this.firstName + &apos; &apos; + this.lastName
}
User.prototype.getAge = function() {
    return new Date() - this.birthDay;
}


module.exports = User;
</code></pre><hr>
<h3 id="test-user-js"><a href="#test-user-js" class="headerlink" title="/test/user.js"></a>/test/user.js</h3><pre><code>var User = require(&quot;../user&quot;);
var chai = require(&quot;chai&quot;)
var expect = chai.expect;


describe(&quot;User&quot;, function(){

// 在测试之前先执行一段代码
var user;
beforeEach(function() {
    user = new User({
        firstName: &quot;Douglas&quot;,
        lastName: &quot;Reynholm&quot;,
        birthDay: new Date(1975,10,2)
    })
});

it(&quot;can extract its name&quot;, function() {
    expect(user.getName()).to.equal(&quot;Douglas Reynholm&quot;)
})
    it(&quot;can get its&apos;s age in milliseconds&quot;, function() {
    var now = new Date();
    expect(user.getAge()).to.equal(now - user.birthDay);
    });
});
</code></pre><hr>
<h3 id="test-txt-js"><a href="#test-txt-js" class="headerlink" title="/test/txt.js"></a>/test/txt.js</h3><pre><code>var app = require(&quot;../app&quot;)
var supertest = require(&quot;supertest&quot;);

describe(&quot;plain text response&quot;, function() {
    var request;

    beforeEach(function() {
        request = supertest(app)
            .get(&quot;/&quot;)
            .set(&quot;User-Agent&quot;, &quot;my cool browser&quot;)
            .set(&quot;Accept&quot;, &quot;text/plain&quot;)
    })

    it(&quot;plain text response&quot;, function(done) {
        request
            .expect(&quot;Content-type&quot;,/text\/plain/)
            .expect(200)
            .end(done)
    });

    it(&quot;returns your User Agent&quot;, function(done) {
        request
            .expect(function(res) {
                if(res.text!== &quot;my cool browser&quot;) {
                    throw new Error(&quot;Response does not container User Agent&quot;)
                }
            })
            .end(done)
    });
})
</code></pre><hr>
<h3 id="html-js"><a href="#html-js" class="headerlink" title="html.js"></a>html.js</h3><pre><code>var app = require(&quot;../app&quot;);
var supertest = require(&quot;supertest&quot;);
var cheerio = require(&quot;cheerio&quot;);

describe(&quot;html response&quot;, function() {
var request;
beforeEach(function() {
    request = supertest(app)
        .get(&quot;/&quot;)
        .set(&quot;User-Agent&quot;, &quot;a cool browser&quot;)
        .set(&quot;Accept&quot;, &quot;text/html&quot;)
});

it(&quot;returns an HTML&quot;, function(done) {
        request
            .expect(&quot;Content-Type&quot;, /html/)
            .expect(200)
            .end(done)
});

    it(&quot;returns your User Agent&quot;, function(done) {
        request
            .expect(function(res) {
                var htmlResponse = res.text;
                var $ = cheerio.load(htmlResponse);
                var userAgent = $(&quot;.user-agent&quot;).html().trim();
                if(userAgent !== &apos;a cool browser&apos;) {
                    throw new Error(&quot;User Agent not found&quot;);
                }
            })
            .end(done)
    });
});
</code></pre><hr>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><pre><code>var express = require(&quot;express&quot;);
var app = express()
var path = require(&quot;path&quot;)

app.set(&quot;port&quot;, process.env.PORT || 3000)

app.set(&quot;view engine&quot;, &quot;ejs&quot;);
var viewPath = path.resolve(__dirname,&quot;views&quot;);
app.set(&quot;views&quot;, viewPath)


app.get(&quot;/&quot;, function(req, res) {
    var userAgent = req.headers[&quot;user-agent&quot;] || &apos;none&apos;;
    if(req.accepts(&quot;html&quot;)) {
        res.render(&quot;index&quot;, {userAgent: userAgent});
    } else {
        res.type(&quot;text&quot;)
        res.send(req.headers[&quot;user-agent&quot;]);
    }
});

app.listen(app.get(&quot;port&quot;),function(){
    console.log(&quot;App started on port &quot; + app.get(&quot;port&quot;));
})

module.exports = app
</code></pre><hr>
<h3 id="view-index-ejs"><a href="#view-index-ejs" class="headerlink" title="view/index.ejs"></a>view/index.ejs</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;style&gt;
        html {
            font-family: sans-serif;
            text-align: center;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Your User Agent is:&lt;/h2&gt;
&lt;h1 class=&quot;user-agent&quot;&gt;
    &lt;%= userAgent %&gt;
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/19/test-unit/" data-id="cj2zypnr70009t6fy90ctbcbz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-passport" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/passport/" class="article-date">
  <time datetime="2017-05-18T14:21:54.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/passport/">passport</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="passport-中间件"><a href="#passport-中间件" class="headerlink" title="passport 中间件"></a>passport 中间件</h3><p>Authenticating requests is as simple as calling passport.authenticate() and specifying which strategy to employ. </p>
<p>standard Connect middleware</p>
<p>By default, if authentication fails, Passport will respond with a 401 Unauthorized status, and any additional route handlers will not be invoked. If authentication succeeds, the next handler will be invoked and the req.user property will be set to the authenticated user.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/passport/" data-id="cj2zypnrb000at6fysysr2or1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-mongodb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/express-mongodb/" class="article-date">
  <time datetime="2017-05-18T03:27:08.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/express-mongodb/">express+mongodb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>express 程序和 mongodb 的结构<br><img src="/2017/05/18/express-mongodb/structure.png" alt="structure"></p>
<h3 id="mongo-配置文件-mongod-conf"><a href="#mongo-配置文件-mongod-conf" class="headerlink" title="mongo 配置文件 mongod.conf"></a>mongo 配置文件 mongod.conf</h3><pre><code>systemLog:
    destination: file
    path: &quot;/var/log/mongodb/mongod.log&quot;
    logAppend: true
storage:
    dbPath: &quot;/data/db&quot;
net:
    bindIp: 127.0.0.1
    port: 27017
</code></pre><h3 id="启动mongo"><a href="#启动mongo" class="headerlink" title="启动mongo"></a>启动mongo</h3><p>mongod –config /etc/mongod.conf        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/express-mongodb/" data-id="cj2zypnqq0004t6fykvqrhf14" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-视图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/express-视图/" class="article-date">
  <time datetime="2017-05-18T03:02:49.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/express-视图/">express 视图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Expres时-视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能"><a href="#Expres时-视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能" class="headerlink" title="Expres时 视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能"></a>Expres时 视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能</h3><p>express 每次render的时候都会创建新的对象交给视图引擎渲染，express 可以设置视图的缓存，而不用每次都重新渲染</p>
<pre><code>app.enabled(&quot;view cache&quot;)
app.disable(&quot;view cache&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/express-视图/" data-id="cj2zypnqx0006t6fy8gmjez8w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Http-状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/Http-状态码/" class="article-date">
  <time datetime="2017-05-18T01:58:41.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/Http-状态码/">Http 状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP 状态诠释，有点意思<br>1xx: hold on<br>2xx: here you go<br>3xx: go away<br>4xx: you messed up<br>5xx: I messed up</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>description</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/Http-状态码/" data-id="cj2zypnqf0001t6fyku6gnzdc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/17/express-router/" class="article-date">
  <time datetime="2017-05-17T15:08:15.000Z" itemprop="datePublished">2017-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/17/express-router/">express-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Express-simple"><a href="#Express-simple" class="headerlink" title="Express simple"></a>Express simple</h3><pre><code>app.get(&quot;/users&quot;, function(request, response) {
response.send(&quot;Users&quot;);
});
</code></pre><h3 id="Express-router-带参数"><a href="#Express-router-带参数" class="headerlink" title="Express router 带参数"></a>Express router 带参数</h3><pre><code>app.get(&quot;/users/:userid&quot;, function(req, res) {
    var userId = parseInt(req.params.userid, 10);
    // ...
}
</code></pre><h3 id="Express-router-用正则匹配，更精细的控制路由"><a href="#Express-router-用正则匹配，更精细的控制路由" class="headerlink" title="Express router 用正则匹配，更精细的控制路由"></a>Express router 用正则匹配，更精细的控制路由</h3><pre><code>app.get(/^\/users\/(\d+)$/, function(req, res) {
    var userId = parseInt(req.params[0], 10);
    // ...
});
</code></pre><p><strong><em>users/</em></strong> 后面带的参数必须为数字</p>
<pre><code>app.get(/^\/users\/(\d+)-(\d+)$/, function(req, res) {
    var startId = parseInt(req.params[0], 10);
    var endId = parseInt(req.params[1], 10);
    // ...
});
</code></pre><p>匹配路由 <strong><em>/users/100-500</em></strong></p>
<h3 id="Express-router-获取查询参数"><a href="#Express-router-获取查询参数" class="headerlink" title="Express router  获取查询参数"></a>Express router  获取查询参数</h3><p><strong><em>／search?keywords=nodejs</em></strong> 通过req.query[‘key’] 获取查询参数</p>
<pre><code>app.get(&quot;/search&quot;, function(req, res) {
   var keywords = req.query.keywords 
// ...
});
</code></pre><hr>
<h3 id="使用router-分割应用"><a href="#使用router-分割应用" class="headerlink" title="使用router 分割应用"></a>使用router 分割应用</h3><blockquote>
<p>A router is an isolated instance of middleware and routes. Routers can be<br>thought of as “mini” applications only capable of performing middleware<br>and routing. Every express application has a built-in app router.</p>
</blockquote>
<p>Routers 可以表现的像中间件，通过.use() 组合到应用中。简而言之，router 将原本庞大的应用分割成一个个mini应用，<br>然后一个个mini应用可以通过类似中间件的方式，将它们拼凑起来，组成一个大型应用。其实router 就是一个基础的middleware。</p>
<h4 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h4><pre><code>var express = require(&quot;express&quot;);
var api = express.Router();
api.use(function(req, res, next) {
    // doing something
    next();
});
api.get(&quot;/users&quot;, function(req, res) { /* ... */ });
api.post(&quot;/user&quot;, function(req, res) { /* ... */ });
module.exports = api;
</code></pre><p> 这看起来就像一个mini的应用，他支持中间件和路由，但他不能单独运行，只能插入到主应用当中去，通过这种方式，就能将应用分割成各个部分了</p>
<hr>
<h3 id="express-static-中间件"><a href="#express-static-中间件" class="headerlink" title="express.static 中间件"></a>express.static 中间件</h3><pre><code>var publicPath = path.resolve(__dirname, &quot;public&quot;);
app.use(express.static(publicPath));
</code></pre><p>设置静态文件夹，path.resolve 支持跨平台的路径解析。默认静态文件夹设置在网站的根目录，然饿你也可以指定静态文件夹的位置。幸运的是Expres中间件可以指定mount的位置，以为着中间件只在制定的位置做出响应。</p>
<blockquote>
<p>Note that this can be done for any middleware, not only the static file middleware.</p>
</blockquote>
<pre><code>var publicPath = path.resolve(__dirname, &quot;public&quot;);
app.use(&apos;/admin&apos;,express.static(publicPath));
</code></pre><p>使用多个静态文件夹 ，because express.static is middleware, you can just apply it multiple times</p>
<pre><code>var publicPath = path.resolve(__dirname, &quot;public&quot;);
var userUploadsPath = path.resolve(__dirname, &quot;user_uploads&quot;);
app.use(express.static(publicPath));
app.use(express.static(userUploadsPath));
</code></pre><p> 因为指定了多个静态文件夹，请求会在这多个文件夹里寻找匹配的资源，找到第一个之后即结束了响应，如果多个文件夹里有重名的资源，就有可能返回错误的资源。所以当有多个静态文件夹时，一般可以通过指定路径的方式来避免冲突。</p>
<pre><code>app.use(&quot;/public&quot;, express.static(publicPath));
app.use(&quot;/uploads&quot;, express.static(userUploadsPath));    
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/17/express-router/" data-id="cj2zypnqt0005t6fyk42pjzqh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Express-常用中间件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/17/Express-常用中间件/" class="article-date">
  <time datetime="2017-05-17T09:52:01.000Z" itemprop="datePublished">2017-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/17/Express-常用中间件/">Express 常用中间件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Express-常用中间件"><a href="#Express-常用中间件" class="headerlink" title="Express 常用中间件"></a>Express 常用中间件</h3><hr>
<ul>
<li>body-parser </li>
<li>cookie-parser</li>
<li>compression</li>
<li>Helmet</li>
<li>connect-assets</li>
<li>bcrypt-nodejs  用于用户密码等的加密</li>
<li>connect-flash</li>
<li>passport 用于用户的验证</li>
<li>passport-local 验证策略</li>
<li>mongoose </li>
<li>pug</li>
<li>passport</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/17/Express-常用中间件/" data-id="cj2zypnq90000t6fyw2xhts5w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-middleware" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/17/express-middleware/" class="article-date">
  <time datetime="2017-05-17T08:15:51.000Z" itemprop="datePublished">2017-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/17/express-middleware/">express middleware</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于Express 中间件执行的一张很好理解的图<br><img src="/2017/05/17/express-middleware/node-middleware.png" alt="express-middleware"></p>
<ol>
<li>在resquest 和 response 之间处理一些任务</li>
<li>middleware stack 是一个元素为函数的数组</li>
<li>在每一个middleware 的中间件函数中都可以修改resquest和response ，在中间件函数中需要对request 作出响应，可以是第一个也可以是最后一个，如果没有响应，服务就会挂起</li>
<li>利用中间件可以将应用分割成一个个组件，便于管理组合</li>
<li>在express 中你可以使用app.use 将中间件函数应用到middleware stack 中</li>
<li>在middleware function 中需要完成resquest的响应或者将request的响应交给下一个middleware function处理，直到完成对resquest的响应</li>
</ol>
<hr>
<h3 id="error-hanlder-middleware"><a href="#error-hanlder-middleware" class="headerlink" title="error-hanlder middleware"></a>error-hanlder middleware</h3><p>有两种中间件<br> . 负责任务处理<br> . 负责错误处理<br> 在中间件里未出现错误，则跳过error-handler middleware，直接交给下一个middleware<br> <img src="/2017/05/17/express-middleware/error-handler-1.png" alt="error-handler"><br> 在中间件里出现错误，则交给error-handler middleware， 结束响应<br> <img src="/2017/05/17/express-middleware/error-handler-2.png" alt="error-handler"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/17/express-middleware/" data-id="cj2zypnqo0003t6fyxs436fjl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Welcome" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/Welcome/" class="article-date">
  <time datetime="2017-05-16T06:47:21.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/Welcome/">welcome</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Welcome-to-Lihuazhidao’s-Blog"><a href="#Welcome-to-Lihuazhidao’s-Blog" class="headerlink" title="Welcome to Lihuazhidao’s Blog"></a>Welcome to Lihuazhidao’s Blog</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/16/Welcome/" data-id="cj2zypnql0002t6fyt33iqa4v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/22/test-e2e/">test-e2e</a>
          </li>
        
          <li>
            <a href="/2017/05/19/test-unit/">test unit</a>
          </li>
        
          <li>
            <a href="/2017/05/18/passport/">passport</a>
          </li>
        
          <li>
            <a href="/2017/05/18/express-mongodb/">express+mongodb</a>
          </li>
        
          <li>
            <a href="/2017/05/18/express-视图/">express 视图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 madao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>