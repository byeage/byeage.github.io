<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Byeage Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Byeage Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Byeage Blog">
<meta property="og:description" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Byeage Blog">
<meta name="twitter:description" content="博客">
  
    <link rel="alternate" href="/atom.xml" title="Byeage Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Byeage Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">白痴总得加把劲</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Collaborative-Web-Development" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/10/Collaborative-Web-Development/" class="article-date">
  <time datetime="2017-07-10T15:02:40.000Z" itemprop="datePublished">2017-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/10/Collaborative-Web-Development/">Collaborative Web Development</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>写高质量的代码</li>
<li>参与开源项目</li>
<li>提高文档化的实践能力</li>
<li>认识到包容和尊重的必要性</li>
</ol>
<p>###写高质量代码需要遵循对原则</p>
<ol>
<li>遵循一些列的标准</li>
<li>使用版本控制</li>
<li>又完好的测试</li>
<li>使用自动检查</li>
</ol>
<p>当我们写代码时需要遵循以下原则，能被共同理解的，能够悲安全修改不会产生副作用的</p>
<p>遵循以下原则</p>
<ul>
<li>使用社区的准则</li>
<li>充分遵守</li>
<li>存储在版本控制器之下</li>
<li>容易阅读和理解！</li>
</ul>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p><img src="https://standardjs.com/" alt="Javascript Standard Style"><br><img src="https://github.com/airbnb/javascript" alt="Airbnb Javascript Style Guide"><br><img src="https://github.com/rwaldron/idiomatic.js" alt="Idiomatic.js"></p>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p><img src="http://codeguide.co/" alt="HTML"></p>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p><img src="https://github.com/necolas/idiomatic-css/tree/master/translations/zh-CN" alt="CSS"></p>
<h3 id="sass-scss"><a href="#sass-scss" class="headerlink" title="sass/scss"></a>sass/scss</h3><p><img src="https://github.com/airbnb/css#sass" alt="Sass"></p>
<ol>
<li><p>充分遵循代码规范。当代码规范放在实际生产中才会起作用，之前介绍了那么多的代码规范，第二步就是遵循哪些代码规范。人工去校验代码显然是枯燥无味也不合适的。好在有一些代码格式化的插件帮我们替换相关工作。一般文本编辑器就可以配置相关内容去运行代码校验，发现错误后回及时提示允许我们去纠正他。比如js的eslint，jslint之类。我们应该让代码校验运行在任何时刻。当代码校验出错时，测试不让通过，当进行版本提交时,代码校验出错时，不让其提交</p>
</li>
<li><p>版本控制的好处</p>
</li>
</ol>
<ul>
<li>加强简化团队合作</li>
<li>能回退变更</li>
<li>开辟项目分枝</li>
<li>代码冲突解决</li>
</ul>
<ol>
<li>测试</li>
</ol>
<ul>
<li>单元测试</li>
<li>功能测试</li>
<li>性能测试</li>
<li>压力测试</li>
<li>扩展性测试</li>
<li>安全测试</li>
<li>回归测试</li>
</ul>
<p>单元测试 javascript + Mocha + Chai<br>浏览器功能测试</p>
<ul>
<li>[BrowserStack] (<a href="https://www.browserstack.com/" target="_blank" rel="external">https://www.browserstack.com/</a>) </li>
<li><a href="https://www.browserling.com/" target="_blank" rel="external">Browserling</a></li>
<li><a href="https://saucelabs.com/" target="_blank" rel="external">Sauce Labs</a></li>
<li><a href="http://webdriver.io/" target="_blank" rel="external">WebDriver.io’s</a></li>
<li><a href="http://docs.seleniumhq.org/" target="_blank" rel="external">Selenium</a></li>
</ul>
<p><img src="https://opendevicelab.com/" alt="终端测试"></p>
<p>测试驱动开发</p>
<ol>
<li>添加测试</li>
<li>运行测试查看是否失败</li>
<li>coding</li>
<li>运行测试</li>
<li>代码重构</li>
<li>repeat</li>
</ol>
<p>自动化集成 <img src="https://travis-ci.org/" alt="travis">  Jenkins<br>结对编程。。。</p>
<h3 id="Code-Reviews"><a href="#Code-Reviews" class="headerlink" title="Code Reviews"></a>Code Reviews</h3><ol>
<li>为每一个参加code review 的人的建议</li>
</ol>
<ul>
<li>接受多不同的编程方式，权衡自己更容易接受的</li>
<li>提出疑问，而不是去强求别人</li>
<li>好的问题避免避免决断，避免假设</li>
<li>避免人身攻击</li>
<li>详细说明，记住别人通常是不会明白你的意图的</li>
<li>持有人性</li>
<li>不嘲讽</li>
<li>保持真实</li>
<li>保持对话同步</li>
</ul>
<ol>
<li>当你自己的代码被reviewed  时，可遵循的建议</li>
</ol>
<ul>
<li>对code reviewer 的建议表示感激</li>
<li>寻求理解reviewer 的观点</li>
<li>解释代码为何存在</li>
<li>尝试对每一个评论进行反馈<br>…</li>
</ul>
<ol>
<li>review 代码时遵循的意见</li>
</ol>
<ul>
<li>理解为何需要改变</li>
<li>对强烈不符合你的意思的进行讨论交流</li>
<li>简化代码能够解决相同的问题</li>
<li>当涉及到哲学问题的时，线下讨论</li>
<li>提供可替代的方案</li>
</ul>
<p>待完善</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/10/Collaborative-Web-Development/" data-id="cj5ap4eab000fhcfyyxj1x7s4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-react-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/29/react-函数/" class="article-date">
  <time datetime="2017-06-29T13:09:56.000Z" itemprop="datePublished">2017-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/29/react-函数/">react-函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>immutability</li>
<li>purity</li>
<li>data transformation</li>
<li>higher-order functions</li>
<li>recursion</li>
<li>Composition</li>
</ol>
<h3 id="immutability-不可变"><a href="#immutability-不可变" class="headerlink" title="immutability 不可变"></a>immutability 不可变</h3><pre><code>In a functional program, data is immutable. It never changes.
</code></pre><p>在函数式编程中数据是不会变的，如何理解 ？</p>
<ul>
<li>不会改变原始数据，函数在原始数据的副本上进行操作。需要注意的是js参数，对象数组传递的都是引用</li>
</ul>
<h3 id="purity-纯函数"><a href="#purity-纯函数" class="headerlink" title="purity  纯函数"></a>purity  纯函数</h3><pre><code>A pure function is a function that returns a value that is computed based on its arguments.
</code></pre><p>纯函数至少接受一个参数，经常返回一个值或另一个参数，如何理解？</p>
<ul>
<li>不会有副作用，不会设置全局变量不会改变应用的任何状态</li>
<li>不会改变函数作用域外值，不会改变参数传进来的值</li>
</ul>
<p>写函数时试着遵循以下原则</p>
<ol>
<li>至少有一个参数</li>
<li>返回一个值或函数</li>
<li>函数不会改变传过来的参数</li>
</ol>
<h4 id="data-transformation-数据变化"><a href="#data-transformation-数据变化" class="headerlink" title="data transformation 数据变化"></a>data transformation 数据变化</h4><pre><code>transform data from one type to another.
</code></pre><p>需要掌握各种js的内置purity函数</p>
<p>Array.map<br>Array.reduce<br>Array.reduceRight<br>Array.filter</p>
<h3 id="higher-order-functions-高阶函数"><a href="#higher-order-functions-高阶函数" class="headerlink" title="higher-order functions 高阶函数"></a>higher-order functions 高阶函数</h3><pre><code>Higher-order functions are functions that can manipulate other functions.
</code></pre><ul>
<li>把函数作为参数传入或者返回函数</li>
<li>柯里化</li>
</ul>
<h3 id="Recursion-递归"><a href="#Recursion-递归" class="headerlink" title="Recursion 递归"></a>Recursion 递归</h3><pre><code>Recursion is a technique that involves creating functions that recall themselves.
</code></pre><ul>
<li>尽可能的用滴贵替代循环</li>
</ul>
<h3 id="Composition-组合"><a href="#Composition-组合" class="headerlink" title="Composition 组合"></a>Composition 组合</h3><p>函数式编程将逻辑分散在各个颗粒度好笑的纯函数当中，最终你需要将这些函数以顺序或者并行的方式整合起来，或者将它们组合成更大的函数</p>
<p>函数式编程三大要点</p>
<ol>
<li>保持数据不可变</li>
<li>纯函数</li>
<li>尽可能递归地带循环</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/29/react-函数/" data-id="cj5ap4ea30009hcfyxgnvk6el" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-research" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/08/research/" class="article-date">
  <time datetime="2017-06-08T06:02:51.000Z" itemprop="datePublished">2017-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/08/research/">research</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="最近需要调研的"><a href="#最近需要调研的" class="headerlink" title="最近需要调研的"></a>最近需要调研的</h1><ol>
<li>webpack 的url-loader 和 resolve-url-loader</li>
<li>客户端存储</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/08/research/" data-id="cj5ap4ea5000ahcfydl8wpj6a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-action" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/25/webpack-action/" class="article-date">
  <time datetime="2017-05-25T06:41:49.000Z" itemprop="datePublished">2017-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/25/webpack-action/">webpack 在自己项目中的配置和使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先回答下之前留下的问题 webpack 和 gulp 这两个工具的区别，也查看了网上相关的讨论。<br>首先给两个官方下的定义<br><strong><em>webpack</em></strong></p>
<blockquote>
<p>webpack is a module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into a small number of bundles - often only one - to be loaded by the browser.</p>
</blockquote>
<hr>
<p><strong><em>gulp</em></strong></p>
<blockquote>
<p>gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something.</p>
</blockquote>
<p>阅读上述两段文字后大概可以看出一点内容来</p>
<ol>
<li>webpack 是一个module bundler，根据依赖关系将所有程序中将会用到的模块打包成少量的包，通常只有一个会被浏览器加载</li>
<li>gulp 开发流程中用于一些自动化的任务和一些耗时的任务 </li>
</ol>
<p>我想两者功能的混淆并不来源于他们两个工具自身的定位，大概来自各自的插件，其中存在一些功能的重叠，比如说一些css编译，js代码压缩等等</p>
<p>在工作的一些体会来说，webpack应该是比较适用于一些模块化开发的单页应用，gulp相对来说应用范围就更广泛些了。</p>
<p>公司在使用vue过程中好像都是使用的vue-cli这个构建工具，倒省去了好多时间和功夫。但要让自己去配置webpack构建一个项目时就感觉很蛋疼😵了，还有就是根据一些特殊要求去修改原本的webpack配置文件时茫然不知怎么去改，所以下面将会介绍一些关于webpack 方面的相关内容。</p>
<p>webpack 核心的四个部分</p>
<ul>
<li>entry  　webpack根据依赖关系将整个应用打包，而entry 正是整个应用的入口，之后再根据依赖关系获取相关内容</li>
<li>output 设置从何获取资源以及将如何打包、打包后的资源输出到哪</li>
<li>loader webpack将所有资源都视为模块，但webpack 只认识javascript ，loader就是将这些文件转换成模块以便让webpack添加到其依赖关系当中</li>
<li>plugins loader 执行文件的转换，plugins 则常用于一些打包模块的编译以及一些自定义的功能，说的好像有些凌乱。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/25/webpack-action/" data-id="cj5ap4ea7000chcfyolxdg9vj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/webpack-vue/" class="article-date">
  <time datetime="2017-05-23T01:55:45.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/webpack-vue/">了解vue2中webpack的相关配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="webppack-使用梳理"><a href="#webppack-使用梳理" class="headerlink" title="webppack  使用梳理"></a>webppack  使用梳理</h3><p>webpack 内部执行流程 <img src="/2017/05/23/webpack-vue/webpack.png" alt="webpack process"></p>
<p>webpack 是一个打包工具，通过配置驱动，配置各种loader，plugins 来实现各个目的。gulp 和 webpack 之间的差别？</p>
<p>首先先讲解下vue-cli构建的vue2项目中webpack的配置 <strong><em>Vue 2.8.1</em></strong><br><img src="/2017/05/23/webpack-vue/structure.png" alt="structure"></p>
<h3 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h3><p>配置文件的结构分为了两个文件夹</p>
<ul>
<li>config<ul>
<li>index.js</li>
<li>dev.env.js</li>
<li>prod.env.js</li>
<li>test.env.js</li>
</ul>
</li>
<li>build<ul>
<li>dev.client.js</li>
<li>dev.server.js</li>
<li>utils.js</li>
<li>vue-loader.js</li>
<li>webpack.base.conf.js</li>
<li>webpack.dev.conf.js</li>
<li>webpack.prod.conf.js</li>
<li>webpack.test.conf.js</li>
</ul>
</li>
</ul>
<p>其实如其名，很好理解每个文件它所代表的意义，下面详解下每个文件, 每个文件都引用了其源码</p>
<h3 id="config-index-js"><a href="#config-index-js" class="headerlink" title="config/index.js"></a>config/index.js</h3><pre><code>// see http://vuejs-templates.github.io/webpack for documentation.
var path = require(&apos;path&apos;)

module.exports = {
    build: {
        env: require(&apos;./prod.env&apos;),
        index: path.resolve(__dirname, &apos;../dist/index.html&apos;),
        assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),
        assetsSubDirectory: &apos;static&apos;,
        assetsPublicPath: &apos;/&apos;,
        productionSourceMap: true,
        // Gzip off by default as many popular static hosts such as
        // Surge or Netlify already gzip all static assets for you.
        // Before setting to `true`, make sure to:
        // npm install --save-dev compression-webpack-plugin
        productionGzip: false,
        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],
        // Run the build command with an extra argument to
        // View the bundle analyzer report after build finishes:
        // `npm run build --report`
        // Set to `true` or `false` to always turn it on or off
        bundleAnalyzerReport: process.env.npm_config_report
    },
    dev: {
        env: require(&apos;./dev.env&apos;),
        port: 8080,
        autoOpenBrowser: true,
        assetsSubDirectory: &apos;static&apos;,
        assetsPublicPath: &apos;/&apos;,
        proxyTable: {},
        // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;
        // with this option, according to the CSS-Loader README
        // (https://github.com/webpack/css-loader#sourcemaps)
        // In our experience, they generally work as expected,
        // just be aware of this issue when enabling this option.
        cssSourceMap: false
    }
}
</code></pre><p>build 是用于生产环境打包生产静态文件时所用的配置项<br>dev 是用于开发当中所有的配置项<br>稍微解释下每个字段的意思</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><table>
<thead>
<tr>
<th>名字</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>env</td>
<td><a href="#config-gt-build-env-js">执行webpack的环境变量</a></td>
</tr>
<tr>
<td>index</td>
<td>应用入口文件的位置及其名称</td>
</tr>
<tr>
<td>assetsRoot</td>
<td>应用资源的根目录</td>
</tr>
<tr>
<td>assetsSubDirectory</td>
<td>应用资源的子目录，用于存放静态资源 </td>
</tr>
<tr>
<td>assetsPublicPath</td>
<td>应用静态资源的引用路径，这边其实需要注意一下，有些项目是一些大项目的子项目 ，当设置为<strong><em>／</em></strong> 时，就会发现 index.html 获取不到其静态资源，这时就需要修改这边的配置了</td>
</tr>
<tr>
<td>productionSourceMap</td>
<td>是否需要生产sourceMap  </td>
</tr>
<tr>
<td>productionGzip</td>
<td>是否需要开启压缩，如需开启需要安装相应插件 </td>
</tr>
<tr>
<td>productionGzipExtensions</td>
<td>需要压缩的文件名的后缀名</td>
</tr>
<tr>
<td>bundleAnalyzerReport</td>
<td>查看打包的分析报告</td>
</tr>
</tbody>
</table>
<h4 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h4><table>
<thead>
<tr>
<th>名字</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>env</td>
<td><a href="#config-gt-dev-env-js">执行webpack的环境变量</a> </td>
</tr>
<tr>
<td>port</td>
<td>webpack-dev-server 服务的端口</td>
</tr>
<tr>
<td>autoOpenBrowser</td>
<td>执行命令时是否自动打开浏览器</td>
</tr>
<tr>
<td>assetsSubDirectory</td>
<td>应用资源的子目录，用于存放静态资源 </td>
</tr>
<tr>
<td>assetsPublicPath</td>
<td>应用静态资源的引用路径 在webpck-dev-server 不存在上述问题</td>
</tr>
<tr>
<td>proxyTable</td>
<td>代理列表 </td>
</tr>
<tr>
<td>cssSourceMap</td>
<td>是否需要生产sourceMap3 </td>
</tr>
</tbody>
</table>
<p>以下三个文件需要注意下的事 <a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="external">webpack-merge</a> 这个插件的使用,一般用于webpack 一些配置文件的合并</p>
<p>这三文件分别导出了它们用于不同目的执行命令时所带的环境变量</p>
<hr>
<h3 id="config-gt-build-env-js"><a href="#config-gt-build-env-js" class="headerlink" title="config&gt;build.env.js"></a>config&gt;build.env.js</h3><pre><code>var merge = require(&apos;webpack-merge&apos;)
var prodEnv = require(&apos;./prod.env&apos;)

module.exports = merge(prodEnv, {
    NODE_ENV: &apos;&quot;development&quot;&apos;
})
</code></pre><p> merge时, {  NODE_ENV: ‘“development”‘} NODE_ENV 这个字段会替换掉prodEnv中NODE_ENV这个地段。对象合并时，相同字段会被替换，不同字段则会保留</p>
<h3 id="config-gt-prod-env-js"><a href="#config-gt-prod-env-js" class="headerlink" title="config&gt;prod.env.js"></a>config&gt;prod.env.js</h3><pre><code>module.exports = {
    NODE_ENV: &apos;&quot;production&quot;&apos;
}
</code></pre><h3 id="config-gt-test-env-js"><a href="#config-gt-test-env-js" class="headerlink" title="config&gt;test.env.js"></a>config&gt;test.env.js</h3><pre><code>var merge = require(&apos;webpack-merge&apos;)
var devEnv = require(&apos;./dev.env&apos;)

module.exports = merge(devEnv, {
    NODE_ENV: &apos;&quot;testing&quot;&apos;
})
</code></pre><hr>
<h3 id="build-utils-js"><a href="#build-utils-js" class="headerlink" title="build/utils.js"></a>build/utils.js</h3><pre><code>var path = require(&apos;path&apos;)
var config = require(&apos;../config&apos;) // 获取config 的配置信息
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) // 提取文本

// 导出静态文件的路径
exports.assetsPath = function (_path) {
    var assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos;
        ? config.build.assetsSubDirectory
        : config.dev.assetsSubDirectory
    return path.posix.join(assetsSubDirectory, _path)
}
// 导出样式的loader
exports.cssLoaders = function (options) {
    options = options || {}

    var cssLoader = {
        loader: &apos;css-loader&apos;,
        options: {
        minimize: process.env.NODE_ENV === &apos;production&apos;,
        sourceMap: options.sourceMap
        }
    }

    // generate loader string to be used with extract text plugin
    function generateLoaders (loader, loaderOptions) {
        var loaders = [cssLoader]
            if (loader) {
            loaders.push({
                loader: loader + &apos;-loader&apos;,
                options: Object.assign({}, loaderOptions, {
                sourceMap: options.sourceMap
                })
            })
        }

        // Extract CSS when that option is specified
        // (which is the case during production build)
        if (options.extract) {
            return ExtractTextPlugin.extract({
                use: loaders,
                fallback: &apos;vue-style-loader&apos;
            })
        } else {
            return [&apos;vue-style-loader&apos;].concat(loaders)
        }
    }

        // https://vue-loader.vuejs.org/en/configurations/extract-css.html
        return {
            css: generateLoaders(),
            postcss: generateLoaders(),
            less: generateLoaders(&apos;less&apos;),
            sass: generateLoaders(&apos;sass&apos;, { indentedSyntax: true }),
            scss: generateLoaders(&apos;sass&apos;),
            stylus: generateLoaders(&apos;stylus&apos;),
            styl: generateLoaders(&apos;stylus&apos;)
    }
}

// Generate loaders for standalone style files (outside of .vue)
exports.styleLoaders = function (options) {
    var output = []
    var loaders = exports.cssLoaders(options)
    for (var extension in loaders) {
        var loader = loaders[extension]
        output.push({
        test: new RegExp(&apos;\\.&apos; + extension + &apos;$&apos;),
        use: loader
        })
    }
    return output
}
</code></pre><p>主要有两个功能吧</p>
<ol>
<li>静态资源文件路径的设置</li>
<li>样式文本的提取<ul>
<li>在 *.vue 文件样式的提取</li>
<li>单独样式文件的提取</li>
</ul>
</li>
</ol>
<h3 id="build-gt-check-versions-js"><a href="#build-gt-check-versions-js" class="headerlink" title="build&gt;check-versions.js"></a>build&gt;check-versions.js</h3><pre><code>var chalk = require(&apos;chalk&apos;)
var semver = require(&apos;semver&apos;)
var packageConfig = require(&apos;../package.json&apos;)
var shell = require(&apos;shelljs&apos;)
    function exec (cmd) {
    return require(&apos;child_process&apos;).execSync(cmd).toString().trim()
}

var versionRequirements = [
    {
        name: &apos;node&apos;,
        currentVersion: semver.clean(process.version),
        versionRequirement: packageConfig.engines.node
    },
]

if (shell.which(&apos;npm&apos;)) {
    versionRequirements.push({
        name: &apos;npm&apos;,
        currentVersion: exec(&apos;npm --version&apos;),
        versionRequirement: packageConfig.engines.npm
    })
}

module.exports = function () {
    var warnings = []
    for (var i = 0; i &lt; versionRequirements.length; i++) {
        var mod = versionRequirements[i]
            if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {
            warnings.push(mod.name + &apos;: &apos; +
                chalk.red(mod.currentVersion) + &apos; should be &apos; +
                chalk.green(mod.versionRequirement)
            )
        }
    }

    if (warnings.length) {
        console.log(&apos;&apos;)
        console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;))
        console.log()
        for (var i = 0; i &lt; warnings.length; i++) {
            var warning = warnings[i]
            console.log(&apos;  &apos; + warning)
        }
        console.log()
        process.exit(1)
    }
}
</code></pre><p>顾名思义，检查执行环境的相关信息，如果执行环境不满足package.json 中所要求的时，给出错误信息，并终止程序。</p>
<h3 id="build-webpack-base-conf-js"><a href="#build-webpack-base-conf-js" class="headerlink" title="build/webpack.base.conf.js"></a>build/webpack.base.conf.js</h3><pre><code>var path = require(&apos;path&apos;)
var utils = require(&apos;./utils&apos;)
var config = require(&apos;../config&apos;)
var vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)

function resolve (dir) {
return path.join(__dirname, &apos;..&apos;, dir)
}

module.exports = {
entry: {
    app: &apos;./src/main.js&apos;
},
output: {
    path: config.build.assetsRoot,
    filename: &apos;[name].js&apos;,
    publicPath: process.env.NODE_ENV === &apos;production&apos;
    ? config.build.assetsPublicPath
    : config.dev.assetsPublicPath
},
resolve: {
    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],
    alias: {
    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,
    &apos;@&apos;: resolve(&apos;src&apos;)
    }
},
module: {
    rules: [
    {
        test: /\.(js|vue)$/,
        loader: &apos;eslint-loader&apos;,
        enforce: &apos;pre&apos;,
        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],
        options: {
        formatter: require(&apos;eslint-friendly-formatter&apos;)
        }
    },
    {
        test: /\.vue$/,
        loader: &apos;vue-loader&apos;,
        options: vueLoaderConfig
    },
    {
        test: /\.js$/,
        loader: &apos;babel-loader&apos;,
        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]
    },
    {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: &apos;url-loader&apos;,
        options: {
        limit: 10000,
        name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)
        }
    },
    {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: &apos;url-loader&apos;,
        options: {
        limit: 10000,
        name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)
        }
    }
    ]
}
}
</code></pre><p>这个就是webpack配置的主要文件，用于生产开发测试的其他配置，都是在这个基础之上再进行拓展的。    </p>
<p>这个最基础的文件配置了四个部分</p>
<ol>
<li>entry 整个应用的入口文件</li>
<li>output 输出文件根目录文件名的一些的配置</li>
<li><p>resolve 解析模块请求的选项</p>
<ul>
<li>指定可以被解析到模块的文件类型</li>
<li>问资源文件设置别名</li>
<li>为获取路径设置了别名 用<strong><em>@</em></strong>代替了之前一长串的路径名，可以在文件在通过 import <strong> from ’@／</strong>‘ 体现出来</li>
</ul>
</li>
<li><p>关于模块的配置</p>
<ul>
<li>eslint ，在js，vue文件中设置代码检查</li>
<li>关于vue 文件loader </li>
<li>关于js 文件loader</li>
<li>关于图片loader</li>
<li>关于字体的loader</li>
</ul>
</li>
</ol>
<hr>
<h3 id="build／webpack-dev-conf-js"><a href="#build／webpack-dev-conf-js" class="headerlink" title="build／webpack.dev.conf.js"></a>build／webpack.dev.conf.js</h3><pre><code>var utils = require(&apos;./utils&apos;)
var webpack = require(&apos;webpack&apos;)
var config = require(&apos;../config&apos;)
var merge = require(&apos;webpack-merge&apos;)
var baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
var FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)

// add hot-reload related code to entry chunks
Object.keys(baseWebpackConfig.entry).forEach(function (name) {
baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat        (baseWebpackConfig.entry[name])
})

module.exports = merge(baseWebpackConfig, {
    module: {
        rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })
    },
    // cheap-module-eval-source-map is faster for development
    devtool: &apos;#cheap-module-eval-source-map&apos;,
    plugins: [
        new webpack.DefinePlugin({
        &apos;process.env&apos;: config.dev.env
        }),
        // https://github.com/glenjamin/webpack-hot-middleware#installation--usage
        new webpack.HotModuleReplacementPlugin(),
        new webpack.NoEmitOnErrorsPlugin(),
        // https://github.com/ampedandwired/html-webpack-plugin
        new HtmlWebpackPlugin({
            filename: &apos;index.html&apos;,
            template: &apos;index.html&apos;,
            inject: true
        }),
        new FriendlyErrorsPlugin()
    ]
})
</code></pre><p>这边主要是开发时webpack的相关设置</p>
<ol>
<li>在entry中设置热加载</li>
<li>重新设置cssLoader</li>
<li>devtool 开发时source-map的设置<a href="https://webpack.js.org/configuration/devtool/" target="_blank" rel="external">devtool</a></li>
<li>插件的设置<ul>
<li>HtmlWebpackPlugin 生成一个HTML文件，为Webpack包提供服务</li>
<li>FriendlyErrorsPlugin</li>
</ul>
</li>
</ol>
<h3 id="build-webpack-prod-conf-js"><a href="#build-webpack-prod-conf-js" class="headerlink" title="build/webpack.prod.conf.js"></a>build/webpack.prod.conf.js</h3><pre><code>var path = require(&apos;path&apos;)
var utils = require(&apos;./utils&apos;)
var webpack = require(&apos;webpack&apos;)
var config = require(&apos;../config&apos;)
var merge = require(&apos;webpack-merge&apos;)
var baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)
var CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)
var OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)

var env = process.env.NODE_ENV === &apos;testing&apos;
? require(&apos;../config/test.env&apos;)
: config.build.env

var webpackConfig = merge(baseWebpackConfig, {
module: {
    rules: utils.styleLoaders({
    sourceMap: config.build.productionSourceMap,
    extract: true
    })
},
devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false,
output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;),
    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)
},
plugins: [
    // http://vuejs.github.io/vue-loader/en/workflow/production.html
    new webpack.DefinePlugin({
    &apos;process.env&apos;: env
    }),
    new webpack.optimize.UglifyJsPlugin({
    compress: {
        warnings: false
    },
    sourceMap: true
    }),
    // extract css into its own file
    new ExtractTextPlugin({
    filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)
    }),
    // Compress extracted CSS. We are using this plugin so that possible
    // duplicated CSS from different components can be deduped.
    new OptimizeCSSPlugin({
    cssProcessorOptions: {
        safe: true
    }
    }),
    // generate dist index.html with correct asset hash for caching.
    // you can customize output by editing /index.html
    // see https://github.com/ampedandwired/html-webpack-plugin
    new HtmlWebpackPlugin({
    filename: process.env.NODE_ENV === &apos;testing&apos;
        ? &apos;index.html&apos;
        : config.build.index,
    template: &apos;index.html&apos;,
    inject: true,
    minify: {
        removeComments: true,
        collapseWhitespace: true,
        removeAttributeQuotes: true
        // more options:
        // https://github.com/kangax/html-minifier#options-quick-reference
    },
    // necessary to consistently work with multiple chunks via CommonsChunkPlugin
    chunksSortMode: &apos;dependency&apos;
    }),
    // split vendor js into its own file
    new webpack.optimize.CommonsChunkPlugin({
    name: &apos;vendor&apos;,
    minChunks: function (module, count) {
        // any required modules inside node_modules are extracted to vendor
        return (
        module.resource &amp;&amp;
        /\.js$/.test(module.resource) &amp;&amp;
        module.resource.indexOf(
            path.join(__dirname, &apos;../node_modules&apos;)
        ) === 0
        )
    }
    }),
    // extract webpack runtime and module manifest to its own file in order to
    // prevent vendor hash from being updated whenever app bundle is updated
    new webpack.optimize.CommonsChunkPlugin({
    name: &apos;manifest&apos;,
    chunks: [&apos;vendor&apos;]
    }),
    // copy custom static assets
    new CopyWebpackPlugin([
    {
        from: path.resolve(__dirname, &apos;../static&apos;),
        to: config.build.assetsSubDirectory,
        ignore: [&apos;.*&apos;]
    }
    ])
]
})

if (config.build.productionGzip) {
var CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)

webpackConfig.plugins.push(
    new CompressionWebpackPlugin({
    asset: &apos;[path].gz[query]&apos;,
    algorithm: &apos;gzip&apos;,
    test: new RegExp(
        &apos;\\.(&apos; +
        config.build.productionGzipExtensions.join(&apos;|&apos;) +
        &apos;)$&apos;
    ),
    threshold: 10240,
    minRatio: 0.8
    })
)
}

if (config.build.bundleAnalyzerReport) {
var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin
webpackConfig.plugins.push(new BundleAnalyzerPlugin())
}

module.exports = webpackConfig
</code></pre><p>这里配置主要包含以下几个模块</p>
<ol>
<li>cssLoader 设置</li>
<li>devtool 设置</li>
<li>输出内容设置<ul>
<li>path 输出路径</li>
<li>filename 输出文件名设置</li>
<li>chunkFilename 打包文件名设置</li>
</ul>
</li>
<li>插件设置<ul>
<li>js 压缩</li>
<li>css文本提取   </li>
<li>提取可复用css</li>
<li>创建HTML文件</li>
<li>公用文件提取</li>
<li>提取模块清单</li>
<li>拷贝静态文件夹</li>
<li>是否压缩</li>
<li>是否生成报告</li>
</ul>
</li>
</ol>
<h3 id="webpack-test-conf-js"><a href="#webpack-test-conf-js" class="headerlink" title="webpack.test.conf.js"></a>webpack.test.conf.js</h3><pre><code>// This is the webpack config used for unit tests.

var utils = require(&apos;./utils&apos;)
var webpack = require(&apos;webpack&apos;)
var merge = require(&apos;webpack-merge&apos;)
var baseConfig = require(&apos;./webpack.base.conf&apos;)

var webpackConfig = merge(baseConfig, {
// use inline sourcemap for karma-sourcemap-loader
module: {
    rules: utils.styleLoaders()
},
devtool: &apos;#inline-source-map&apos;,
resolveLoader: {
    alias: {
    // necessary to to make lang=&quot;scss&quot; work in test when using vue-loader&apos;s ?inject option 
    // see discussion at https://github.com/vuejs/vue-loader/issues/724
    &apos;scss-loader&apos;: &apos;sass-loader&apos;
    }
},
plugins: [
    new webpack.DefinePlugin({
    &apos;process.env&apos;: require(&apos;../config/test.env&apos;)
    })
]
})

// no need for app entry during tests
delete webpackConfig.entry

module.exports = webpackConfig
</code></pre><p>以上部分用于测试</p>
<ol>
<li>cssLoader 设置</li>
<li>devtool 设置</li>
<li>css提取模块设置</li>
<li>插件设置</li>
<li>删除入口文件</li>
</ol>
<h3 id="build-dev-client-js"><a href="#build-dev-client-js" class="headerlink" title="build/dev-client.js"></a>build/dev-client.js</h3><pre><code>/* eslint-disable */
require(&apos;eventsource-polyfill&apos;)
var hotClient = require(&apos;webpack-hot-middleware/client?noInfo=true&amp;reload=true&apos;)

hotClient.subscribe(function (event) {
    if (event.action === &apos;reload&apos;) {
        window.location.reload()
    }
})
</code></pre><p>以上部分为客户端设置热加载</p>
<h3 id="build-dev-server-js"><a href="#build-dev-server-js" class="headerlink" title="build/dev-server.js"></a>build/dev-server.js</h3><pre><code>require(&apos;./check-versions&apos;)()

var config = require(&apos;../config&apos;)
    if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)
}

var opn = require(&apos;opn&apos;)
var path = require(&apos;path&apos;)
var express = require(&apos;express&apos;)
var webpack = require(&apos;webpack&apos;)
var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)
var webpackConfig = process.env.NODE_ENV === &apos;testing&apos;
? require(&apos;./webpack.prod.conf&apos;)
: require(&apos;./webpack.dev.conf&apos;)

// default port where dev server listens for incoming traffic
var port = process.env.PORT || config.dev.port
// automatically open browser, if not set will be false
var autoOpenBrowser = !!config.dev.autoOpenBrowser
// Define HTTP proxies to your custom API backend
// https://github.com/chimurai/http-proxy-middleware
var proxyTable = config.dev.proxyTable

var app = express()
var compiler = webpack(webpackConfig)

var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {
    publicPath: webpackConfig.output.publicPath,
    quiet: true
})

var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler, {
    log: () =&gt; {}
})
// force page reload when html-webpack-plugin template changes
compiler.plugin(&apos;compilation&apos;, function (compilation) {
    compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) {
            hotMiddleware.publish({ action: &apos;reload&apos; })
            cb()
    })
})

// proxy api requests
Object.keys(proxyTable).forEach(function (context) {
var options = proxyTable[context]
if (typeof options === &apos;string&apos;) {
    options = { target: options }
}
app.use(proxyMiddleware(options.filter || context, options))
})

// handle fallback for HTML5 history API
app.use(require(&apos;connect-history-api-fallback&apos;)())

// serve webpack bundle output
app.use(devMiddleware)

// enable hot-reload and state-preserving
// compilation error display
app.use(hotMiddleware)

// serve pure static assets
var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)
app.use(staticPath, express.static(&apos;./static&apos;))

var uri = &apos;http://localhost:&apos; + port

var _resolve
var readyPromise = new Promise(resolve =&gt; {
    _resolve = resolve
})

console.log(&apos;&gt; Starting dev server...&apos;)
devMiddleware.waitUntilValid(() =&gt; {
console.log(&apos;&gt; Listening at &apos; + uri + &apos;\n&apos;)
// when env is testing, don&apos;t need open it
if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !== &apos;testing&apos;) {
    opn(uri)
}
_resolve()
})

var server = app.listen(port)

module.exports = {
    ready: readyPromise,
    close: () =&gt; {
        server.close()
    }
}
</code></pre><p>这里居然用的是express 而不是webpack-dev-server </p>
<ol>
<li>webpack-dev中间件设置</li>
<li>热加载中间件设置</li>
<li>express API 代理设置</li>
<li>express HTML history API 设置</li>
<li>express 静态资源文件夹设置</li>
</ol>
<p>这边的内容主要集中在express这个服务器和webpack中间件的设置</p>
<h3 id="build-build-js"><a href="#build-build-js" class="headerlink" title="build/build.js"></a>build/build.js</h3><pre><code>require(&apos;./check-versions&apos;)()

process.env.NODE_ENV = &apos;production&apos;
var ora = require(&apos;ora&apos;)
var rm = require(&apos;rimraf&apos;)
var path = require(&apos;path&apos;)
var chalk = require(&apos;chalk&apos;)
var webpack = require(&apos;webpack&apos;)
var config = require(&apos;../config&apos;)
var webpackConfig = require(&apos;./webpack.prod.conf&apos;)

var spinner = ora(&apos;building for production...&apos;)
spinner.start()

rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; {
if (err) throw err
webpack(webpackConfig, function (err, stats) {
    spinner.stop()
    if (err) throw err
    process.stdout.write(stats.toString({
    colors: true,
    modules: false,
    children: false,
    chunks: false,
    chunkModules: false
    }) + &apos;\n\n&apos;)

    console.log(chalk.cyan(&apos;  Build complete.\n&apos;))
    console.log(chalk.yellow(
    &apos;  Tip: built files are meant to be served over an HTTP server.\n&apos; +
    &apos;  Opening index.html over file:// won\&apos;t work.\n&apos;
    ))
})
})
</code></pre><p>这边就相对简单了<br>主要有两点</p>
<ol>
<li>清除之前已有静态资源内容</li>
<li>执行webpack 打包命令</li>
<li>执行信息的提示</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/23/webpack-vue/" data-id="cj5ap4ea9000ehcfy616xt0ko" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test-e2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/test-e2e/" class="article-date">
  <time datetime="2017-05-22T09:55:00.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/22/test-e2e/">test-e2e</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是nightwatch？"><a href="#什么是nightwatch？" class="headerlink" title="什么是nightwatch？"></a>什么是nightwatch？</h3><p><a href="http://nightwatchjs.org/api#expect-negation" target="_blank" rel="external">nightwatch</a> 是一个用nodejs 写的用于网站和网页应用的自动化测试框架。简化可持续集成的设置和测试的编写，也可以用于nodejs的单元测试</p>
<p>设置配置可看官方文档，有点复杂😅，这里主要讲讲如何在Vue-cli 构建的项目里使用nightwatch 进行end-to-end测试</p>
<p>在test/e2e/specs/ 文件下有一个默认的测试文件的例子 test.js， nightwatch.conf.js 和 runner.js 都为配置文件，custom-assertions 里面为自定义断言，reports 为测试报告</p>
<p>首先得先停运运行你的npm run dev  ctrl + c 。 不然运行下你的 npm run e2e时候就嗝屁了，这看下他的配置大概就能理解了</p>
<pre><code>module.exports = {
    &apos;default e2e tests&apos;: function (browser) {  // 测试描述
        // automatically uses dev Server port from /config.index.js // 用于测试的服务器
        // default: http://localhost:8080 //  默认测试端口
        // see nightwatch.conf.js  // nightwatch 的配置文件

        const devServer = browser.globals.devServerURL  // 测试地址

        browser
        .url(devServer)    // A
        .waitForElementVisible(&apos;#app&apos;, 5000) //B  
        .assert.elementPresent(&apos;.hello&apos;) // C
        .assert.containsText(&apos;h1&apos;, &apos;Welcome to Your Vue.js App&apos;) // D
        .assert.elementCount(&apos;img&apos;, 1) // E
        .end() // F
    }
}
</code></pre><ul>
<li>A 浏览器加载目标地址</li>
<li>B 在断言之前等待5000让页面中#app的元素可见 ，如果在设置对时间内，元素未出现，测试失败</li>
<li>C 页面有存在 .hello 元素</li>
<li>D h1 标签里包含文本 ‘Welcome to Your Vue.js App’</li>
<li>E 页面了有img元素1个</li>
<li>F 结束</li>
</ul>
<h3 id="在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子-baidu-js"><a href="#在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子-baidu-js" class="headerlink" title="在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子 baidu.js"></a>在介绍一个官方的例子，上面用的是谷歌的例子，需要翻墙我这边稍微修改下使用百度做例子 baidu.js</h3><pre><code>module.exports = {
    &apos;Demo test Baidu&apos;: function (browser) {
        browser
        .url(&apos;https://www.baidu.com/&apos;)
        .waitForElementVisible(&apos;body&apos;, 1000)
        .setValue(&apos;input#kw&apos;, &apos;邪马台&apos;)  // A
        .waitForElementVisible(&apos;input#su&apos;, 1000) // B
        .click(&apos;input#su&apos;) // C
        .pause(1000) // D
        .assert.containsText(&apos;#container&apos;, &apos;邪马台_百度百科&apos;) // E
        .end()
    }
}
</code></pre><p>上面讲过的就不重复了 </p>
<ul>
<li>A 等待body页面加载，设置百度搜索框的值为‘邪马台’</li>
<li>B 等待百度搜索提交按钮出现（这个其实默认就有，沿着谷歌的例子没去掉）</li>
<li>C 触发鼠标单击事件，模拟搜索</li>
<li>D 等待1秒</li>
<li>E 断言#container 元素里文本包含 ‘邪马台_百度百科’</li>
</ul>
<h3 id="分步测试-muiltiple-step-js"><a href="#分步测试-muiltiple-step-js" class="headerlink" title="分步测试 muiltiple-step.js"></a>分步测试 muiltiple-step.js</h3><p>module.exports = {<br>        ‘Step one’: function (browser) {<br>            browser<br>            .url(‘<a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a>‘)<br>            .waitForElementVisible(‘body’, 1000)<br>            .setValue(‘input#kw’, ‘邪马台’)<br>            .waitForElementVisible(‘input#su’, 1000)<br>            .click(‘input#su’)<br>            .pause(1000)<br>        },<br>        ‘Step two’: function(browser) {<br>            browser<br>            .assert.containsText(‘#container’, ‘邪马台_百度百科’)<br>            .end()<br>        }<br>    }</p>
<p>这个就很好理解了，不做过多解释</p>
<h3 id="使用选择器-selectors-js"><a href="#使用选择器-selectors-js" class="headerlink" title="使用选择器 selectors.js"></a>使用选择器 selectors.js</h3><pre><code>module.exports = {
    &apos;selector Test&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;/index&apos;
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        .useXpath() // A
        .assert.containsText(&apos;//*[@id=&quot;app&quot;]/div[1]/h1[2]&apos;, &apos;Test example&apos;)
        .useCss() // B
        .assert.containsText(&apos;.test-example&apos;, &apos;Test example&apos;)
        .end()
    }
}
</code></pre><ul>
<li>A 使用xpath 选择器 谷歌F12 在Element里选择元素右键copy 选择 copy Xpath 具体规则自己百度</li>
<li>B 使用Css 选择器</li>
</ul>
<h3 id="BBT-行为驱动开发测试-其实是一种断言的方式，极大提高了断言的可读性和优雅性😂-。具体语法参照-chai"><a href="#BBT-行为驱动开发测试-其实是一种断言的方式，极大提高了断言的可读性和优雅性😂-。具体语法参照-chai" class="headerlink" title="BBT 行为驱动开发测试  其实是一种断言的方式，极大提高了断言的可读性和优雅性😂 。具体语法参照 chai"></a>BBT 行为驱动开发测试  其实是一种断言的方式，极大提高了断言的可读性和优雅性😂 。具体语法参照 <a href="http://chaijs.com/api/" target="_blank" rel="external">chai</a></h3><pre><code>module.exports = {
    &apos;BBD-style Test&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;/index&apos;

        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        browser.expect.element(&apos;.test-hello&apos;).to.be.present
        browser.expect.element(&apos;.test-hello&apos;).text.to.equal(&apos;Welcome to Your Vue.js App&apos;)
        browser.expect.element(&apos;.test-hello&apos;).text.to.contain(&apos;Welcome&apos;)
        browser.expect.element(&apos;.test-hello&apos;).to.be.an(&apos;h1&apos;)
        browser.expect.element(&apos;.test-hello&apos;).to.be.visible
        browser.end()
    }
}
</code></pre><p>有个缺点是expect 不能用链式的方式些，每个断言必须单独使用，expect 相对于 asserts 使用</p>
<h3 id="测试中的钩子"><a href="#测试中的钩子" class="headerlink" title="测试中的钩子"></a>测试中的钩子</h3><pre><code>module.exports = {
    before: function(browser) {
        console.log(&apos;Setting up...&apos;);// A
    },
    after: function(browser) {
        console.log(&apos;Closing down...&apos;); // B
    },

    beforeEach: function(browser) { // C
        const devServer = browser.globals.devServerURL
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 3000)
    },

    afterEach: function(browser, done) { // D
        console.log(&apos;each end&apos;)
        done()
    },

    &apos;hook Test .test-example&apos;: function (browser) {
        browser
        .assert.containsText(&apos;.test-example&apos;, &apos;Test example&apos;)
        .end()
    },
    &apos;hook Test .test-hello&apos;: function (browser) {
        browser
        .assert.containsText(&apos;.test-hello&apos;, &apos;Welcome to Your Vue.js App&apos;)
        .end()
    }
};
</code></pre><ul>
<li>A 在整个测试运行之前运行一次</li>
<li>B 在整个测试完成之后运行一次</li>
<li>C 在每一个小测试运行之前运行一次</li>
<li>D 在每一次小测试运行完之后运行一次</li>
</ul>
<h3 id="现在拿一个自己写的Vue的例子-index-js"><a href="#现在拿一个自己写的Vue的例子-index-js" class="headerlink" title="现在拿一个自己写的Vue的例子 index.js"></a>现在拿一个自己写的Vue的例子 index.js</h3><pre><code>module.exports = {
    &apos;Index e2e tests&apos;: function (browser) {
        const devServer = browser.globals.devServerURL + &apos;#/index&apos; // 需要测试的地址
        browser
        .url(devServer)
        .waitForElementVisible(&apos;#app&apos;, 5000)
        .assert.elementPresent(&apos;.show&apos;) // 默认显示是存在的
        .click(&apos;.switch&apos;) // click 之后 show 为false
        .assert.elementNotPresent(&apos;.show&apos;) // 元素不存在了
        .end()
    }
}
</code></pre><h3 id="待续……"><a href="#待续……" class="headerlink" title="待续……"></a>待续……</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/test-e2e/" data-id="cj5ap4ea6000bhcfy5dwr26l5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test-unit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/19/test-unit/" class="article-date">
  <time datetime="2017-05-19T02:58:01.000Z" itemprop="datePublished">2017-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/19/test-unit/">test unit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>测试可以分成几类，单元测试，集成测试</li>
<li>TDD（测试驱动开发）直白的说就是先写测试用例，再写代码，直到测试通过</li>
</ul>
<p>代码不出错一般是不正常的（共识）。测试一般指是自动测试的简称，运行测试代码来验证自己写的代码</p>
<p>进行代码测试的好处</p>
<ul>
<li>增强对自己代码的信任度，（为好找借口推脱责任增强自信心） 😀</li>
<li>当你修改、重构代码时，不需要人工再去验证重构完后的代码有没有问题</li>
<li>验证你的代码是正常可行的</li>
</ul>
<h3 id="Test-driven-development-TDD"><a href="#Test-driven-development-TDD" class="headerlink" title="Test-driven development TDD"></a>Test-driven development TDD</h3><p>TDD 测试的三个流程<br><img src="/2017/05/19/test-unit/tdd.png" alt="TDD"></p>
<ol>
<li>red Step 在你写真实的代码之前，先写测试用例的代码。当然写完之后的测试用例都是通不过的</li>
<li>green step 在完测试用例之后开始写你自己真实的代码，过程中，测试用例会一个个的通过，由red 状态转成 red 状态，一旦通过所有测试用例，就跳转到了step 3</li>
<li>refactor step 重构优化阶段， 可以放纵的重构，反正由测试代码帮你验证通过与否</li>
<li>repeat process  添加新的测试用例，重复上述步骤</li>
</ol>
<p>常用测试工具 <strong><em>Mocha</em></strong> <strong><em>chai</em></strong> <strong><em>supertest</em></strong> <strong><em>cheerio</em></strong></p>
<p><img src="/2017/05/19/test-unit/structure.png" alt="structure"></p>
<h3 id="capitalize-js"><a href="#capitalize-js" class="headerlink" title="capitalize.js"></a>capitalize.js</h3><pre><code>function capitalize(str) {
    var firstLetter = str.charAt(0).toUpperCase();
    var rest = str.slice(1).toLowerCase();
    return firstLetter + rest
}

module.exports = capitalize;
</code></pre><hr>
<h3 id="test-capitalize-js"><a href="#test-capitalize-js" class="headerlink" title="/test/capitalize.js"></a>/test/capitalize.js</h3><pre><code>var capitialize = require(&apos;../capitalize&apos;);
var chai = require(&quot;chai&quot;);
var expect = chai.expect;

describe(&quot;capitalize&quot;, function() {
    it(&quot;capitializes single words&quot;, function() {
        expect(capitialize(&quot;express&quot;)).to.equal(&quot;Express&quot;);
        expect(capitialize(&quot;cats&quot;)).to.equal(&quot;Cats&quot;);
    })

    it(&quot;makes the rest of the string lowercase&quot;, function(){
        expect(capitialize(&quot;javaScript&quot;)).to.equal(&quot;Javascript&quot;);
    })
    it(&quot;leaves empty strings alone&quot;, function () {
        expect(capitialize(&quot;&quot;)).to.equal(&quot;&quot;);
    })
    it(&quot;throws an error if passed a number&quot;, function() {
        expect(function() {
            capitialize(123)
        }).to.throw(Error)
    })
    // 反向测试
    it(&quot;changes the value&quot;, function() {
        expect(capitialize(&quot;foo&quot;)).not.to.equal(&quot;foo&quot;);
    })
})
</code></pre><hr>
<h3 id="user-js"><a href="#user-js" class="headerlink" title="user.js"></a>user.js</h3><pre><code>function User(params) {
    this.firstName = params.firstName || &apos;&apos;;
    this.lastName = params.lastName || &apos;&apos;;
    this.birthDay = params.birthday || &apos;&apos;;
}

User.prototype.getName = function() {
    return this.firstName + &apos; &apos; + this.lastName
}
User.prototype.getAge = function() {
    return new Date() - this.birthDay;
}


module.exports = User;
</code></pre><hr>
<h3 id="test-user-js"><a href="#test-user-js" class="headerlink" title="/test/user.js"></a>/test/user.js</h3><pre><code>var User = require(&quot;../user&quot;);
var chai = require(&quot;chai&quot;)
var expect = chai.expect;


describe(&quot;User&quot;, function(){

// 在测试之前先执行一段代码
var user;
beforeEach(function() {
    user = new User({
        firstName: &quot;Douglas&quot;,
        lastName: &quot;Reynholm&quot;,
        birthDay: new Date(1975,10,2)
    })
});

it(&quot;can extract its name&quot;, function() {
    expect(user.getName()).to.equal(&quot;Douglas Reynholm&quot;)
})
    it(&quot;can get its&apos;s age in milliseconds&quot;, function() {
    var now = new Date();
    expect(user.getAge()).to.equal(now - user.birthDay);
    });
});
</code></pre><hr>
<h3 id="test-txt-js"><a href="#test-txt-js" class="headerlink" title="/test/txt.js"></a>/test/txt.js</h3><pre><code>var app = require(&quot;../app&quot;)
var supertest = require(&quot;supertest&quot;);

describe(&quot;plain text response&quot;, function() {
    var request;

    beforeEach(function() {
        request = supertest(app)
            .get(&quot;/&quot;)
            .set(&quot;User-Agent&quot;, &quot;my cool browser&quot;)
            .set(&quot;Accept&quot;, &quot;text/plain&quot;)
    })

    it(&quot;plain text response&quot;, function(done) {
        request
            .expect(&quot;Content-type&quot;,/text\/plain/)
            .expect(200)
            .end(done)
    });

    it(&quot;returns your User Agent&quot;, function(done) {
        request
            .expect(function(res) {
                if(res.text!== &quot;my cool browser&quot;) {
                    throw new Error(&quot;Response does not container User Agent&quot;)
                }
            })
            .end(done)
    });
})
</code></pre><hr>
<h3 id="html-js"><a href="#html-js" class="headerlink" title="html.js"></a>html.js</h3><pre><code>var app = require(&quot;../app&quot;);
var supertest = require(&quot;supertest&quot;);
var cheerio = require(&quot;cheerio&quot;);

describe(&quot;html response&quot;, function() {
var request;
beforeEach(function() {
    request = supertest(app)
        .get(&quot;/&quot;)
        .set(&quot;User-Agent&quot;, &quot;a cool browser&quot;)
        .set(&quot;Accept&quot;, &quot;text/html&quot;)
});

it(&quot;returns an HTML&quot;, function(done) {
        request
            .expect(&quot;Content-Type&quot;, /html/)
            .expect(200)
            .end(done)
});

    it(&quot;returns your User Agent&quot;, function(done) {
        request
            .expect(function(res) {
                var htmlResponse = res.text;
                var $ = cheerio.load(htmlResponse);
                var userAgent = $(&quot;.user-agent&quot;).html().trim();
                if(userAgent !== &apos;a cool browser&apos;) {
                    throw new Error(&quot;User Agent not found&quot;);
                }
            })
            .end(done)
    });
});
</code></pre><hr>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><pre><code>var express = require(&quot;express&quot;);
var app = express()
var path = require(&quot;path&quot;)

app.set(&quot;port&quot;, process.env.PORT || 3000)

app.set(&quot;view engine&quot;, &quot;ejs&quot;);
var viewPath = path.resolve(__dirname,&quot;views&quot;);
app.set(&quot;views&quot;, viewPath)


app.get(&quot;/&quot;, function(req, res) {
    var userAgent = req.headers[&quot;user-agent&quot;] || &apos;none&apos;;
    if(req.accepts(&quot;html&quot;)) {
        res.render(&quot;index&quot;, {userAgent: userAgent});
    } else {
        res.type(&quot;text&quot;)
        res.send(req.headers[&quot;user-agent&quot;]);
    }
});

app.listen(app.get(&quot;port&quot;),function(){
    console.log(&quot;App started on port &quot; + app.get(&quot;port&quot;));
})

module.exports = app
</code></pre><hr>
<h3 id="view-index-ejs"><a href="#view-index-ejs" class="headerlink" title="view/index.ejs"></a>view/index.ejs</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;style&gt;
        html {
            font-family: sans-serif;
            text-align: center;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Your User Agent is:&lt;/h2&gt;
&lt;h1 class=&quot;user-agent&quot;&gt;
    &lt;%= userAgent %&gt;
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/19/test-unit/" data-id="cj5ap4ea8000dhcfyfsgz1803" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-passport" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/passport/" class="article-date">
  <time datetime="2017-05-18T14:21:54.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/passport/">passport</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="passport-中间件"><a href="#passport-中间件" class="headerlink" title="passport 中间件"></a>passport 中间件</h3><p>Authenticating requests is as simple as calling passport.authenticate() and specifying which strategy to employ. </p>
<p>standard Connect middleware</p>
<p>By default, if authentication fails, Passport will respond with a 401 Unauthorized status, and any additional route handlers will not be invoked. If authentication succeeds, the next handler will be invoked and the req.user property will be set to the authenticated user.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/passport/" data-id="cj5ap4ea20008hcfymy8x9nvp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-mongodb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/express-mongodb/" class="article-date">
  <time datetime="2017-05-18T03:27:08.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/express-mongodb/">express+mongodb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>express 程序和 mongodb 的结构<br><img src="/2017/05/18/express-mongodb/structure.png" alt="structure"></p>
<h3 id="mongo-配置文件-mongod-conf"><a href="#mongo-配置文件-mongod-conf" class="headerlink" title="mongo 配置文件 mongod.conf"></a>mongo 配置文件 mongod.conf</h3><pre><code>systemLog:
    destination: file
    path: &quot;/var/log/mongodb/mongod.log&quot;
    logAppend: true
storage:
    dbPath: &quot;/data/db&quot;
net:
    bindIp: 127.0.0.1
    port: 27017
</code></pre><h3 id="启动mongo"><a href="#启动mongo" class="headerlink" title="启动mongo"></a>启动mongo</h3><p>mongod –config /etc/mongod.conf        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/express-mongodb/" data-id="cj5ap4e9u0004hcfyn65dyct7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express-视图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/express-视图/" class="article-date">
  <time datetime="2017-05-18T03:02:49.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/express-视图/">express 视图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Expres时-视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能"><a href="#Expres时-视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能" class="headerlink" title="Expres时 视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能"></a>Expres时 视图选择上还是选择PUG比较好，语法简介，有layout，mixins功能</h3><p>express 每次render的时候都会创建新的对象交给视图引擎渲染，express 可以设置视图的缓存，而不用每次都重新渲染</p>
<pre><code>app.enabled(&quot;view cache&quot;)
app.disable(&quot;view cache&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/express-视图/" data-id="cj5ap4e9v0005hcfyk0gknikr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/10/Collaborative-Web-Development/">Collaborative Web Development</a>
          </li>
        
          <li>
            <a href="/2017/06/29/react-函数/">react-函数</a>
          </li>
        
          <li>
            <a href="/2017/06/08/research/">research</a>
          </li>
        
          <li>
            <a href="/2017/05/25/webpack-action/">webpack 在自己项目中的配置和使用</a>
          </li>
        
          <li>
            <a href="/2017/05/23/webpack-vue/">了解vue2中webpack的相关配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 madao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>